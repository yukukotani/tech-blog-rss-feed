<!doctype html><html lang="ja"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="企業のテックブログの更新をまとめたRSSフィードを配信しています。記事を読んでその企業の技術・カルチャーを知れることや、質の高い技術情報を得られることを目的としています。"><meta name="author" content="yamadashy"><meta name="robots" content="index, follow"><meta property="og:url" content="https://yamadashy.github.io/tech-blog-rss-feed/"><meta property="og:title" content="開発ブログ｜株式会社Nextat（ネクスタット）のフィード｜企業テックブログRSS"><meta property="og:image" content="https://yamadashy.github.io/tech-blog-rss-feed/images/og-image.png"><meta property="og:description" content="企業のテックブログの更新をまとめたRSSフィードを配信しています。記事を読んでその企業の技術・カルチャーを知れることや、質の高い技術情報を得られることを目的としています。"><meta property="og:type" content="website"><meta property="og:site_name" content="企業テックブログRSS"><meta property="og:locale" content="ja_JP"><meta name="twitter:card" content="summary"><meta property="twitter:domain" content="https://yamadashy.github.io/tech-blog-rss-feed/"><meta 
property="twitter:url" content="https://yamadashy.github.io/tech-blog-rss-feed/"><meta name="twitter:title" content="開発ブログ｜株式会社Nextat（ネクスタット）のフィード｜企業テックブログRSS"><meta name="twitter:description" content="企業のテックブログの更新をまとめたRSSフィードを配信しています。記事を読んでその企業の技術・カルチャーを知れることや、質の高い技術情報を得られることを目的としています。"><meta name="twitter:image" content="https://yamadashy.github.io/tech-blog-rss-feed/images/og-image.png"><meta name="thumbnail" content="https://yamadashy.github.io/tech-blog-rss-feed/images/og-image.png"><link rel="preload" href="../../styles/bundle.css" as="style"><meta name="google-site-verification" content="GPLvXv8kYtLMW912ZS54DKFEZL6ruOrjOFLdHVTo37o"><link rel="shortcut icon" href="../../images/favicon.ico"><link rel="apple-touch-icon" href="../../images/apple-icon.png"><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="../../feeds/atom.xml"><link rel="alternate" type="application/rss+xml" title="RSS2.0" href="../../feeds/rss.xml"><link rel="alternate" 
type="application/json" href="../../feeds/feed.json"><link rel="stylesheet" type="text/css" href="../../styles/bundle.css"><script async src="https://www.googletagmanager.com/gtag/js?id=G-CNNNTL0NB3"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-CNNNTL0NB3")</script><title>開発ブログ｜株式会社Nextat（ネクスタット）のフィード｜企業テックブログRSS</title></head><body><header role="banner" class="ui-section-header"><div class="ui-layout-container"><div class="ui-section-header__layout ui-layout-flex"><a href="https://yamadashy.github.io/tech-blog-rss-feed/" role="link" aria-label="#"><img src="../../images/icon.png" alt="サイトロゴ" loading="eager" width="96" height="96"> <span class="ui-section-header__title">企業テックブログRSS</span> </a><a href="https://github.com/yamadashy/tech-blog-rss-feed/" role="link" aria-label="#"><img src="../../images/github-mark.png" alt="GitHubロゴ" loading="eager" width="96" height="96"></a></div></div></header>
<main role="main"><nav class="ui-nav"><div class="ui-layout-container"><div class="ui-section-nav__layout ui-layout-flex"><a class="ui-section-nav__link" href="../../">フィード</a> <a class="ui-section-nav__link" href="../../hot/">人気フィード</a> <a class="ui-section-nav__link" href="../../blogs/">ブログ一覧</a></div></div></nav><section class="ui-section-content ui-section-feed"><div class="ui-layout-container"><h2 class="ui-typography-heading">開発ブログ｜株式会社Nextat（ネクスタット）</h2><div class="ui-container-blog-summary"><div class="ui-blog-summary"><a class="ui-blog-summary__link" href="https://nextat.co.jp/">https://nextat.co.jp/</a><p class="ui-blog-summary__description">京都を中心にシステム開発・Webサイト・ホームページ制作を行なっているシステム開発・Web制作会社Nextat（ネクスタット）の公式サイトです。Webサイトの開発から業務支援システムの開発まで幅広く手がけています。ホームページ製作は、SEOやCMS、更新・運用など、お客様に合わせた最適なサービスをご提案します。</p></div></div><h3 class="ui-typography-heading">フィード</h3><div class="ui-section-content--feature ui-layout-grid ui-layout-grid-3 ui-container-feed ui-container-feed--no-image"><div 
class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://nextat.co.jp/staff/archives/346"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://nextat.co.jp/staff/archives/346">Onyx言語でHTTPサーバーを実装し、Wasmer Edgeにデプロイする</a><div class="ui-feed-item__blog-title">開発ブログ｜株式会社Nextat（ネクスタット）</div><div class="ui-feed-item__summary">
こんにちは、ナカエです。 先週末は少し暖かかったかと思えばまた寒くなりましたね。本日の記事はWasmer Edgeというエッジにアプリケーションをデプロイできるサービスと新しいプログラミング言語である Onyx を合わせて試したという内容です。まずはそれぞれの簡単な紹介から入ります。Wasmer EdgeとはWasmer Edge はエッジロケーションにWebAssemblyのランタイムを展開し、Wasmバイナリをアプリケーションとして安価にスケーラブルに動かせると謳うサービスです。米Wasmer社が提供しています。個人的にはブラウザ側だけでなくサーバー側であるエッジでまでJavaScript/TypeScriptという選択肢だけになるのはちょっと……という気持ちがあり、エッジでのWasmの実行についても興味を寄せています。ユーザーに近いロケーションでコンテナを動かす、ということであれば Fly.io などでもやっていることですが、Wasmランタイムがコンテナランタイムの代替手段となりえるならセキュリティ面やパフォーマンス面で有利です。利用側もアプリの実装以外で考えることが減るのではないかと期待しています。Docker DesktopにWebAssemblyランタイムが統合される などの動きもあり、今後エコシステムの整備は加速していきそうです。Wasmer Edge はまだBetaではありますが10/6にGAとなっており、Tokyoリージョンも追加されています。競合との比較にてコールドスタートが 50ナノ秒と表記されていたり、HTTP接続だけではなくTCP接続も扱えるとメリットをアピールしており、自信のほどが窺えます。言語サポートには Rust, JS, C, Python, Ruby とあり、現時点でも一般的なエッジコンピューティングのサービスより対応幅が広いです。Wasmを生成できるなら言語はなんでもいい、という感じになってくれれば素晴らしいですね。プログラミング言語 Onyx とはWasmer社がブログで紹介したことで話題になった Onyx はWebAssemblyへのコンパイルに特化した言語で、開発者は Brendan Hansen 氏です。Wasm特化というだけあってWebAssemblyへのコンパイルが非常に高速とのこと。また、Onyxの構文は、Go、J
</div><div class="ui-feed-item__date" title="2023-12-19 06:00:00">1ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://nextat.co.jp/staff/archives/345"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://nextat.co.jp/staff/archives/345">【Laravel】@use()ディレクティブを紹介</a><div class="ui-feed-item__blog-title">開発ブログ｜株式会社Nextat（ネクスタット）</div><div class="ui-feed-item__summary">
【Laravel】@use()ディレクティブを紹介こんにちは、かっちゃんです。 今回はLaravel 10.35でリリースされたbladeでの機能を紹介します。動作環境PHP: 8.2.10Laravel Framework: 10.35.0@use()ディレクティブについてblade内でPHPクラスをインポートしたい時に今までは以下のように@phpディレクティブを利用して記載していました。@php use App&#92;Models&#92;User;@endphpしかし今回新しくリリースされた@useディレクティブを使用すると以下のように記述することができます。 実際に確認してみました{{ User::class }} // Userこちらだけで確認してみますとUserのみが表示されました。次に@use(&#39;App&#92;Models&#92;User&#39;){{ User::class }} // App&#92;Models&#92;Userで確認してみたとことApp&#92;Models&#92;Userと表示され正常に動作していることが確認できました。@use(&#39;App&#92;Models&#92;User&#39;, &#39;UserEloquentModel&#39;){{ UserEloquentModel::class }} // App&#92;Models&#92;User参考https://laravel-news.com/laravel-10-35-0最後に以上新しく追加された@use()ディレクティブについての紹介となります。Notificationクラスを用いたメール実装時にbladeを使用する機会もあると思いますので、頭の片隅においておくと良さそうです。ありがとうございました。</div><div class="ui-feed-item__date" title="2023-12-11 06:03:02">1ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://nextat.co.jp/staff/archives/344"><img 
src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://nextat.co.jp/staff/archives/344">【Laravel】JsonResourceクラスのwhen, mergeWhenメソッドを紹介</a><div class="ui-feed-item__blog-title">開発ブログ｜株式会社Nextat（ネクスタット）</div><div class="ui-feed-item__summary">
こんにちは、モリです。 今回は、JsonResourceクラスを拡張したクラスで使用できるメソッドwhen, mergeWhenについて紹介します。環境PHP: 8.1Laravel Framework: 10.20.0whenメソッド日々の業務でJSONレスポンスを返すAPIを実装することが多く、そうした場合Illuminate&#92;Http&#92;Resources&#92;Json&#92;JsonResourceを継承したクラスを作成して取得したリソースをJSON構造に変換しています。class BannerResource extends JsonResource{ /** * @var Banner */ public $resource; public function toArray($request): array { $baseData = [ &#39;id&#39; =&gt; $this-&gt;resource-&gt;id, &#39;name&#39; =&gt; $this-&gt;resource-&gt;name, ]; if ($this-&gt;resource-&gt;type === BannerType::IMAGE) { $baseData = array_merge($baseData, [&#39;imageUrl&#39; =&gt; $this-&gt;resource-&gt;image_url]); } return $baseData; }}リソースのタイプ($this-&gt;resource-&gt;type)が画像(image)の場合は、imageUrlを含めた配列を返すようにしています。 こうした状況で、whenメソッドを使うと以下のように書くことができます。 public function toArray($request): array { return [ &#39;id&#39; =&gt; $this-&gt;resource-&gt;id, &#39;name&#39; =&gt; $this-&gt;resource-&gt;name, &#39;imageUrl&#39; =&gt; $this-&gt;when($this-&gt;resource-&gt;type === BannerType::IMAGE, $this-&gt;resource-&gt;image_url), ]; }whenメソッドを使わない場合と比べてすっきりした形で書くことができました。 public function toArray($request): array
</div><div class="ui-feed-item__date" title="2023-12-04 06:00:00">1ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://nextat.co.jp/staff/archives/343"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://nextat.co.jp/staff/archives/343">【Laravel】PostgreSQLのtrigger機能を使って履歴を取る方法</a><div class="ui-feed-item__blog-title">開発ブログ｜株式会社Nextat（ネクスタット）</div><div class="ui-feed-item__summary">
こんにちは。本ブログではLaravelのインストール方法は説明しません環境履歴作成説明TG_OPで、実行された操作(insert,update,delete)を判定可能です。NEWで、入力されたデータを取得できます。OLDで、更新前のデータを取得できます。NEW.status != OLD.statusで比較することで、変更があったかを判定します。 CREATE TRIGGER trigger_settlement_status_update_or_create AFTER INSERT OR UPDATE ON settlements FOR EACH ROW EXECUTE FUNCTION update_insert_settlement_status_history(); AFTERの後に、実行されるタイミングを指定します。IF (TG_OP = &#92;&#39;UPDATE&#92;&#39;)等が実行されないので注意してください。EXECUTE FUNCTIONで、実行するfunctionを指定します。 DB::unprepared(&#39;DROP TRIGGER trigger_settlement_status_update_or_create ON settlements&#39;); DB::unprepared(&#39;DROP FUNCTION update_insert_settlement_status_history&#39;); downで、functionとtriggerを削除しています。まとめPostgreSQLのtrigger機能を用いることで、履歴を作成することができます。functionを使えば色々とできるので、ぜひ使ってみてください。本日は以上となります。</div><div class="ui-feed-item__date" title="2023-11-17 07:29:01">2ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://nextat.co.jp/staff/archives/342"><img 
src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://nextat.co.jp/staff/archives/342">【Laravel】Collectionの新機能percentage()使ってみた</a><div class="ui-feed-item__blog-title">開発ブログ｜株式会社Nextat（ネクスタット）</div><div class="ui-feed-item__summary">
初めまして、今年の7月からNextatに仲間入りしたおさむちゃんです。環境PHP: 8.2Laravel Framework: 10.19percentageメソッドとは使い方$users = collect([ [&#39;name&#39; =&gt; &#39;おさむちゃん&#39;, &#39;age&#39; =&gt; 18], [&#39;name&#39; =&gt; &#39;かっちゃん&#39;, &#39;age&#39; =&gt; 30], [&#39;name&#39; =&gt; &#39;もりりん&#39;, &#39;age&#39; =&gt; 34],]);$users-&gt;percentage(fn ($user) =&gt; $user[&#39;age&#39;] &gt;= 30); // 66.66$users-&gt;percentage(fn ($user) =&gt; $user[&#39;age&#39;] &lt; 20); // 33.33$users-&gt;percentage(fn ($user) =&gt; $user[&#39;age&#39;] &lt; 20, precision: 3); // 33.333参考https://laravel-news.com/laravel-10-19-0https://readouble.com/laravel/10.x/ja/collections.html#method-percentage最後に今回はpercentageメソッドを紹介させていただきました。複雑な計算やフィルタリングを行う必要がなく、直感的に記載することができて便利ですよね。ぜひ皆さんも使ってみてください。</div><div class="ui-feed-item__date" title="2023-11-01 03:24:29">2ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://nextat.co.jp/staff/archives/341"><img 
src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://nextat.co.jp/staff/archives/341">【React】useSWRInfiniteを使って追加ローディングボタンを作る</a><div class="ui-feed-item__blog-title">開発ブログ｜株式会社Nextat（ネクスタット）</div><div class="ui-feed-item__summary">
はじめにはじめまして。今年の５月から入社したヨシです。普段は主にフロントエンドでの開発に携わらせて頂いています (たまに Laravel なども触ります)。今回はじめての開発ブログの記事となりますが、普段は個人での技術記事やブログなどを趣味で書いているので、なるべく気負わずに楽しく書いていきたいなと思っていますのでよろしくお願いします。この記事では、現在開発中のプロジェクトで出会った SWR の useSWRInfinite フックについて書いてみたいと思います。実は useSWRInfinite の使い方自体は公式ドキュメントに記載してあるとおりに行えば簡単に利用できますが、このフックに渡す getKey 関数の使い方がいまいち分かりづらく、すこしハマったでので特にそれについての知見を書いていきたいと思います。環境Next.js: 13.3.4React: 18.2.0SWR: 2.2.2SWR とはまずはじめに SWR とはなにかを説明しておくと、SWR は React で利用できるデータ取得のための React Hooks のライブラリです。SWR を使うことで React での非同期のデータ取得を useEffect を利用することなく、簡単に扱えるようになります。リクエストには “loading”、“ready”、“error” という３つの状態があり、以下のようにそれらの状態に対応する data、error、isLoading を分割代入で useSWR フックから取得して、条件によってレンダリングするものを指定してあげます。import useSWR from &quot;swr&quot;;function App() { const { data, error, isLoading } = useSWR(`/api/user/${userId}`, fetcher); if (error) return &lt;div&gt;ロード失敗...&lt;/div&gt;; if (isLoading) return &lt;div&gt;ローディング中...&lt;/div&gt;; // データフェッチに成功してローディングが完了すればデータを表示 return &lt;div&gt;hello {data.name}&lt;/div&gt;;}useSWRInfiniteSWR ライブラリで利用できる基本のフックである useSWR につ
</div><div class="ui-feed-item__date" title="2023-10-30 07:24:30">2ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://nextat.co.jp/staff/archives/340"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://nextat.co.jp/staff/archives/340">【Laravel】LaravelのstoredAsとvirtualAsの活用方法と違い</a><div class="ui-feed-item__blog-title">開発ブログ｜株式会社Nextat（ネクスタット）</div><div class="ui-feed-item__summary">
お久しぶりです、たけちゃんです。Laravelでは格納生成列、仮想生成列を作成する際に使うメソッドとしてそれぞれ環境本題`ColumnDefinition::storedAs()`: 格納生成列を追加具体例Schema::table(&#39;users&#39;, function (Blueprint $table) { $table-&gt;string(&#39;name_upper&#39;)-&gt;storedAs(&#39;UPPER(name)&#39;);});メリットデータの永続的な変換: `ColumnDefinition::storedAs()`を使用すると、データを変換してストレージに保存します。パフォーマンス向上: データベースからデータを取得する際、必要な変換がすでに行われているため、クエリのパフォーマンスが向上します。デメリットストレージ使用量: `ColumnDefinition::storedAs()`で生成されたカラムはストレージを使用します。余分なストレージを必要とするため、大規模なテーブルでは注意が必要になってきます。`ColumnDefinition::virtualAs()`: 仮想生成列の追加具体例Schema::table(&#39;users&#39;, function (Blueprint $table) { $table-&gt;virtualAs(&#39;UPPER(name)&#39;, &#39;name_upper&#39;);});メリットストレージ節約: 仮想生成列はデータベースに保存されないため、ストレージを節約できます。動的な生成: クエリの実行時に動的に生成されるため、データの変更に対応する柔軟性があります。デメリットパフォーマンス: 仮想生成列はクエリ実行時に毎回計算されるため、大規模なテーブルでのパフォーマンスに影響を与える可能性があります。まとめ参考文献MySQL公式ドキュメントLaravel10.x公式ドキュメントPostgreSQL公式ドキュメント</div><div class="ui-feed-item__date" title="2023-10-23 06:00:00">3ヶ月前</div></div></div><div class="ui-feed-item"><a 
class="ui-feed-item__og-image" href="https://nextat.co.jp/staff/archives/338"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://nextat.co.jp/staff/archives/338">【Unity】Unity.Matchmatics.quaternion.AxisAngleのangleはラジアン</a><div class="ui-feed-item__blog-title">開発ブログ｜株式会社Nextat（ネクスタット）</div><div class="ui-feed-item__summary">四元数（クォータニオン）とは、複素数を拡張した数体系です。環境本題UnityEngine.Quaternion.AngleAxisの場合、引数のangleの単位は度(degree)です。Unity.Mathematics.quaternion.AxisAngleの場合はドキュメントによると&gt; by an angle in radiansということなので引数のangleにはラジアンを渡しましょう。</div><div class="ui-feed-item__date" title="2023-10-16 06:00:00">3ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://nextat.co.jp/staff/archives/336"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div 
class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://nextat.co.jp/staff/archives/336">【Rust】RustでWebAPIを作って、UnityクライアントからAPIコールしてみる【Unity】</a><div class="ui-feed-item__blog-title">開発ブログ｜株式会社Nextat（ネクスタット）</div><div class="ui-feed-item__summary">
こんにちは。最近涼しくなってきて嬉しいホンジョウです。Axum GitHubリポジトリ開発環境macOS 13.4 Venturarustc 1.72.0cargo 1.72.0Unity 2022.2.21インストール方法に関してはこちらをご確認ください。Cargo.tomlの編集​[package]name = &quot;rust_web_api&quot;version = &quot;0.1.0&quot;edition = &quot;2021&quot;# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[dependencies]axum = &quot;0.6.1&quot;tokio = { version = &quot;1.23.0&quot;, features = [&quot;full&quot;] }serde = { version = &quot;1.0.149&quot;, features = [&quot;derive&quot;] }serde_json = &quot;1.0.89&quot;Rustプロジェクトのディレクトリ構成mod.rsの記述users.rsの記述main.rsの記述この時点で実行してみて、問題なくJSONが返ってくるようであれば、「RustでWebAPIを作ってみた」はこれにて完成です。 それでは次にUnityクライアント側の処理を書いていきましょう。Unityプロジェクトのディレクトリ構成User.csの記述UserInfoView.csSceneInitializer.csの記述(json); view.UpdateUserInfo(user); } }}Sceneの作成と実行参考資料Rust の Web フレームワーク Axum で REST API を作るRustでWebAPIを構築し単純なリクエストデータを返してみる</div><div class="ui-feed-item__date" title="2023-10-10 06:00:00">3ヶ月前</div></div></div><div class="ui-feed-item"><a 
class="ui-feed-item__og-image" href="https://nextat.co.jp/staff/archives/335"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://nextat.co.jp/staff/archives/335">S3にあるはずのPDFファイルがダウンロードできないの、なぁぜなぁぜ？</a><div class="ui-feed-item__blog-title">開発ブログ｜株式会社Nextat（ネクスタット）</div><div class="ui-feed-item__summary">
こんにちは、さわちゃんです。今日はS3にあるはずのPDFファイルがダウンロードできない（厳密に言うとダウンロードディレクトリに保存されずに直接ブラウザで開かれてしまう）現象について、基礎的なところを見落としていたので共有したいと思います。環境Laravel + Inertiaを利用したMPAで、フロントのフレームワークはReactを採用しています。Laravel v10.5.1Inertia.js v0.6.9React v9.5.0（今回はどのフレームワーク・ライブラリでも起こり得るので↑の事項はあんまり関係ないです）起きた現象S3に保存されていたPDFファイルをブラウザでダウンロードする機能があり、フロント側では以下のようなコードを書いてダウンロードする仕組みを実装しました。&lt;a href={S3にアップされたファイルURL} download={ファイル名}&gt; ダウンロード！&lt;/a&gt;いざブラウザでこのリンクを踏んでみると、なぜかダウンロードは行われず、PDFファイルの内容がブラウザ上に表示されてしまうという挙動になりました。原因HTTPレスポンスヘッダでした。S3のURLにアクセスした際のHTTPレスポンスヘッダがContent-Type: application/pdfになっていて、ブラウザにPDFだよ！と教えてしまっていました。ブラウザくん「お、PDFやんけ！ならワシがバシッと中身を表示したる！」ということで、ダウンロードされずに表示されてしまったんですね。解決策HTTPレスポンスヘッダのContent-Typeを以下のように変更しましょう。Content-Type: binary/octet-streamそうすることによって「とりあえずこれはファイルですよ！」ってことをブラウザに伝えることができるので、ダウンロードできるようになります。S3に直接ファイルをアップしている場合は、S3のファイルのメタデータを直接いじるLaravelからファイルアップロードを行う場合は、メタデータを指定した上でアップロードするなどの対応が必要ですね。アプリ（Laravel）側で行うとしたら以下のように指定できます。Storage::put($fileName, $contents, [ &#39;mimetype&#39; =&gt; &#39;binary/octet-stream&#39;,]);逆にPDFを
</div><div class="ui-feed-item__date" title="2023-09-29 11:02:27">4ヶ月前</div></div></div></div></div></section></main><footer role="contentinfo" class="ui-section-footer"><div class="ui-layout-container"><div class="ui-layout-column-6 ui-layout-column-center"><div class="ui-component-cta ui-layout-flex ui-section-footer__site-info"><p class="ui-text-note">このサイトは<br>記事を読んでその企業の技術・カルチャーを知れることや<br>質の高い技術情報を得られることを目的としています。</p><p class="ui-text-note">追加したいブログがある場合は<br><a href="https://github.com/yamadashy/tech-blog-rss-feed#%E3%82%B5%E3%82%A4%E3%83%88%E3%81%AE%E8%BF%BD%E5%8A%A0%E6%96%B9%E6%B3%95">サイトの追加方法</a> をご参照ください。</p></div></div></div><div class="ui-layout-container"><div class="ui-section-footer__layout ui-layout-flex"><p class="ui-section-footer--copyright ui-text-note"><a class="ui-text-note" href="https://github.com/yamadashy/"><small>@yamadashy</small></a></p><a href="https://github.com/yamadashy/tech-blog-rss-feed/" role="link" aria-label="#" class="ui-text-note"><small>GitHub
</small></a></div></div></footer></body></html>