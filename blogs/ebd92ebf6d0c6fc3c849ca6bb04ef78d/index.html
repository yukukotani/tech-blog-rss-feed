<!doctype html><html lang="ja"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="企業のテックブログの更新をまとめたRSSフィードを配信しています。記事を読んでその企業の技術・カルチャーを知れることや、質の高い技術情報を得られることを目的としています。"><meta name="author" content="yamadashy"><meta name="robots" content="index, follow"><meta property="og:url" content="https://yamadashy.github.io/tech-blog-rss-feed/"><meta property="og:title" content="sitateru tech blogのフィード｜企業テックブログRSS"><meta property="og:image" content="https://yamadashy.github.io/tech-blog-rss-feed/images/og-image.png"><meta property="og:description" content="企業のテックブログの更新をまとめたRSSフィードを配信しています。記事を読んでその企業の技術・カルチャーを知れることや、質の高い技術情報を得られることを目的としています。"><meta property="og:type" content="website"><meta property="og:site_name" content="企業テックブログRSS"><meta property="og:locale" content="ja_JP"><meta name="twitter:card" content="summary"><meta property="twitter:domain" content="https://yamadashy.github.io/tech-blog-rss-feed/"><meta 
property="twitter:url" content="https://yamadashy.github.io/tech-blog-rss-feed/"><meta name="twitter:title" content="sitateru tech blogのフィード｜企業テックブログRSS"><meta name="twitter:description" content="企業のテックブログの更新をまとめたRSSフィードを配信しています。記事を読んでその企業の技術・カルチャーを知れることや、質の高い技術情報を得られることを目的としています。"><meta name="twitter:image" content="https://yamadashy.github.io/tech-blog-rss-feed/images/og-image.png"><meta name="thumbnail" content="https://yamadashy.github.io/tech-blog-rss-feed/images/og-image.png"><link rel="preload" href="../../styles/bundle.css" as="style"><meta name="google-site-verification" content="GPLvXv8kYtLMW912ZS54DKFEZL6ruOrjOFLdHVTo37o"><link rel="shortcut icon" href="../../images/favicon.ico"><link rel="apple-touch-icon" href="../../images/apple-icon.png"><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="../../feeds/atom.xml"><link rel="alternate" type="application/rss+xml" title="RSS2.0" href="../../feeds/rss.xml"><link rel="alternate" type="application/json" 
href="../../feeds/feed.json"><link rel="stylesheet" type="text/css" href="../../styles/bundle.css"><script async src="https://www.googletagmanager.com/gtag/js?id=G-CNNNTL0NB3"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-CNNNTL0NB3")</script><title>sitateru tech blogのフィード｜企業テックブログRSS</title></head><body><header role="banner" class="ui-section-header"><div class="ui-layout-container"><div class="ui-section-header__layout ui-layout-flex"><a href="https://yamadashy.github.io/tech-blog-rss-feed/" role="link" aria-label="#"><img src="../../images/icon.png" alt="サイトロゴ" loading="eager" width="96" height="96"> <span class="ui-section-header__title">企業テックブログRSS</span> </a><a href="https://github.com/yamadashy/tech-blog-rss-feed/" role="link" aria-label="#"><img src="../../images/github-mark.png" alt="GitHubロゴ" loading="eager" width="96" height="96"></a></div></div></header><main role="main"><nav 
class="ui-nav"><div class="ui-layout-container"><div class="ui-section-nav__layout ui-layout-flex"><a class="ui-section-nav__link" href="../../">フィード</a> <a class="ui-section-nav__link" href="../../hot/">人気フィード</a> <a class="ui-section-nav__link" href="../../blogs/">ブログ一覧</a></div></div></nav><section class="ui-section-content ui-section-feed"><div class="ui-layout-container"><h2 class="ui-typography-heading">sitateru tech blog</h2><div class="ui-container-blog-summary"><div class="ui-blog-summary"><a class="ui-blog-summary__link" href="https://tech-blog.sitateru.com/">https://tech-blog.sitateru.com/</a><p class="ui-blog-summary__description">シタテルの技術やエンジニアの取り組みを紹介します。</p></div></div><h3 class="ui-typography-heading">フィード</h3><div class="ui-section-content--feature ui-layout-grid ui-layout-grid-3 ui-container-feed ui-container-feed--no-image"><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2021/12/ghcr-public.html"><img 
src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2021/12/ghcr-public.html">GitHub Container Registryに公開リポジトリを作ってみた</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
みなさんはコンテナイメージはどこに置いているでしょうか。GHCRとはコンテナレジストリの利用 - GitHub Docs料金ですが、パブリックなパッケージについては無料となってます。今回のニーズにはちょうどいいですね。About billing for GitHub Packages - GitHub Docsイメージのpull/push等は ghcr.io/&lt;OWNER&gt;/&lt;IMAGE_NAME&gt;:&lt;tag&gt; という表記になります。(OWNERはGitHubのユーザー名やorganization名になります)push前などに認証する場合は以下のようになります。write:packages スコープを持つアクセストークンを作っておく$ echo &lt;token&gt; | docker login ghcr.io -u USERNAME --password-stdinリポジトリ作成・pushというわけで、organizationのPackagesにコンテナイメージをアップロードして公開してみましょう。$ echo $GH_TOKEN | docker login ghcr.io -u sitateru --password-stdin$ docker pull hello-world:latest$ docker tag hello-world:latest ghcr.io/sitateru/hello-world:latest$ docker push ghcr.io/sitateru/hello-world:latestアップロードしたパッケージは、https://github.com/orgs/&amp;lt;OWNER&gt;/packagesのURLで一覧できます。organizationにアップロードすると、最初はInternalというアクセス設定になるようです。Change package visiblity をクリックしてPublicを選択。リポジトリと紐づけ作成したパッケージにはリポジトリを紐づけできるようになっています。Connect Repository をクリックしてリポジトリを選択すればOKです。紐づけするとリポジトリのREADMEがパッケージのREADMEとして表示されるほか、パッケージのアクセス権限を「紐づけたリポジトリと等しくする」ことができます。管理の
</div><div class="ui-feed-item__date" title="2021-12-22 09:04:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2021/10/efs-persistentvolume-eks.html"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2021/10/efs-persistentvolume-eks.html">Amazon EFSを使ってEKSに永続ボリュームを導入した</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
AWS EKSで動かしているアプリケーション用にEFSを使って永続ボリュームを用意してみたので、その方法をまとめてみようと思います。とあるテスト用Kubernetes環境でMySQLのイメージを使ってデータベースを動かしているのですが、何かの拍子にpodが一旦削除などされてしまうとデータベースの中身のデータが全て無くなってしまいます。手順はほぼこのドキュメントどおりですが、一部変えないと動かなかった箇所があるのでその点も触れつつ書いてみようと思います。Amazon EFS CSI ドライバードキュメントに従っても動かないよ！という件のissueはこちら。Missing permission in the example IAM policy file · Issue #489 · kubernetes-sigs/aws-efs-csi-driver · GitHubまた、今回やってみた環境は以下のようになっています。Amazon EFS CSI ドライバーまずはIAMポリシーを作成します。{ &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;elasticfilesystem:DescribeAccessPoints&quot;, &quot;elasticfilesystem:DescribeFileSystems&quot;, &quot;elasticfilesystem:DescribeMountTargets&quot;, &quot;ec2:DescribeAvailabilityZones&quot; ], &quot;Resource&quot;: &quot;*&quot; }, { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;elasticfilesystem:CreateAccessPoint&quot; ], &quot;Resource&quot;: &quot;*&quot;, &quot;Condition&quot;: { &quot;StringLike&quot;: { &quot;aws:RequestTag/efs.csi.aws.com/cluster&quot;: &quot;true&quot; } } }, { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: &quot;elasticfilesystem:DeleteAccessPoint&quot;, &quot;Resource&quot;: &quot;*&quot;, &quot;Condition&quot;: { &quot;StringEquals&quot;:
</div><div class="ui-feed-item__date" title="2021-10-14 08:06:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2021/08/aws-app-mesh-on-eks-3.html"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2021/08/aws-app-mesh-on-eks-3.html">AWS App Mesh をEKSで試してみた（仮想ゲートウェイ）</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
前回に続き、EKS上でのAWS App Meshをやっていきます。今回は、仮想ゲートウェイです。今回の内容もドキュメント等いまいち見つからなかったので正確さなどは怪しいところがありますがご了承ください🙇‍♂️Virtual gateways - AWS App Mesh仮想ゲートウェイ作成まずは仮想ゲートウェイとそのルートを作成します。apiVersion: appmesh.k8s.aws/v1beta2kind: VirtualGatewaymetadata: namespace: mesh-test name: gateway-vspec: namespaceSelector: matchLabels: mesh: mesh-1 podSelector: matchLabels: for: gateway listeners: - portMapping: port: 8088 protocol: http connectionPool: http: maxConnections: 1024 logging: accessLog: file: path: /dev/stdout---apiVersion: appmesh.k8s.aws/v1beta2kind: GatewayRoutemetadata: namespace: mesh-test name: gateway-v-route-vspec: httpRoute: action: target: virtualService: virtualServiceRef: name: svc-v match: prefix: /ゲートウェイ作成ゲートウェイの実体となる、envoyイメージのコンテナと type: LoadBalancer な サービスを作成します。apiVersion: apps/v1kind: Deploymentmetadata: name: gateway-v namespace: mesh-testspec: replicas: 1 selector: matchLabels: for: gateway template: metadata: labels: for: gateway spec: serviceAccountName: appmesh-proxyauth contai...
</div><div class="ui-feed-item__date" title="2021-08-27 09:19:00">2年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2021/06/aws-app-mesh-on-eks-2.html"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2021/06/aws-app-mesh-on-eks-2.html">AWS App Mesh をEKSで試してみた（仮想ルーター、仮想サービス）</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
前回に続き、EKS上でのAWS App Meshをやっていきます。あまりしっかり説明されたドキュメントが見つからず経験ベースな部分が多いので、正しい説明になっているかどうか怪しい部分もありますがご了承ください🙇‍仮想ルーター作成仮想ノードへトラフィックを振り分ける仮想ルーターを作成します。weightedTargets の virtualNodeRef.name で仮想ノード名を指定します。apiVersion: appmesh.k8s.aws/v1beta2kind: VirtualRoutermetadata: namespace: mesh-test name: vrouter-1spec: listeners: - portMapping: port: 80 protocol: http routes: - name: route-1 httpRoute: match: prefix: / action: weightedTargets: - virtualNodeRef: name: vnode-1 weight: 1 - virtualNodeRef: name: vnode-2 weight: 1仮想サービス用サービス作成仮想サービスの実体にするserviceを作成します。selecter は、仮想サービスを介してアクセスする先のpodが全て含まれるように指定する必要があるみたいです。app: sample1 のラベルをつけてあります。apiVersion: v1kind: Servicemetadata: name: svc-v namespace: mesh-test labels: app: sample1spec: type: ClusterIP selector: app: sample1 ports: - protocol: TCP port: 80 targetPort: 80仮想サービス作成先の svc-v を実体とする仮想サービスを作成します。name は上で仮想サービス用に作ったサービス名と等しくする必要があるみたいです。provider には仮想サービスを通してアクセスする先を指定を指定します。単一のvirtualNodeかvirtualRouterを選択できるので、トラフィックを複数ノードに分けたいならvirtualRoute...
</div><div class="ui-feed-item__date" title="2021-06-17 08:55:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2021/06/aws-app-mesh-on-eks-1.html"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2021/06/aws-app-mesh-on-eks-1.html">AWS App Mesh をEKSで試してみた（準備～仮想ノードまで）</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
突然ですが、AWS App Meshは皆さんお使いでしょうか？サービスメッシュといえばIstioが有名ですが、AWS App MeshはAWS製だけあってEKSはもちろんEC2やECSのインスタンス・コンテナもメッシュに組み込むことができるのが強みという印象です。そんなApp MeshをEKS上でいろいろと実験してみたので、自分の理解の反芻のためにもまとめてみたいと思います。試した環境は kubernetes 1.20, App Meshコントローラ 1.3.0 でした。準備ドキュメントに従ってコントローラをインストールします。Getting started with AWS App Mesh and Kubernetes - AWS App Mesh手順はドキュメントの通りなのでここでは書きませんが、完了するとappmesh-systemネームスペースでコントローラのポッドができていました。$ kubectl get pod -n appmesh-systemNAME READY STATUS RESTARTS AGEappmesh-controller-6c55b46558-8s363 1/1 Running 0 1dmesh作成メッシュを作成します。egressFilter はメッシュ内部から外部へのアクセスを許可するかどうかですね。許可しない場合はDROP_ALLにします。namespaceSelecter も何でもいいので書いておきましょう。apiVersion: appmesh.k8s.aws/v1beta2kind: Meshmetadata: name: mesh-1spec: egressFilter: type: ALLOW_ALL namespaceSelector: matchLabels: mesh: sitateru-meshnamespace作成メッシュのリソースを配置するネームスペースを宣言します。namespaceSelector とラベルを合わせておきましょう。appmesh.k8s.aws/sidecarInjectorWebhook をenabledにしてEnvoyサイドカーが入れられるようにしておく必要があります。apiVersion: v1kind: Namespacemetadata: name: mesh-test l
</div><div class="ui-feed-item__date" title="2021-06-03 09:06:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2021/04/questionnaire-desktop-app.html"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2021/04/questionnaire-desktop-app.html">シタテル開発陣に聞いてみた：便利なデスクトップアプリ</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
今回はちょっと新企画として、シタテルの開発部にアンケートをとって記事を書いてみようかと思います。第1回は、「日々の開発業務で便利なデスクトップアプリを聞いてみた」です😁初めての試みということもあり、まずはジャンル問わずで募集してみました。早速コメントとともにまとめてみたいと思います。Sidekick説明Webブラウザ＋アプリまとめアプリ特にいいと思うところChromiumベースのブラウザとアプリ集約が一体化したようなアプリです。縦にアプリ、横にブラウザタブが並んで管理できるので1ウィンドウで一覧性よく収まります。1passwordなどのブラウザ拡張機能が使えるのがうれしいところで、StationやBiscuitなどとの一番の差別化ポイントだと思っています。Sequel Ace説明mysqlのGUIツールWorkbenchより軽快な気がするAlacritty説明クロスプラットフォームのターミナルエミュレータ特にいいと思うところGPUによる高速なレンダリングYAMLファイルで設定できて、別のOSでも同じ設定が使えて便利RubyMine説明JetBrains製のRubyに特化したIDE特にいいと思うところ補完、コードジャンプ、検索など開発に必要な機能が特別な設定無しですぐ使えるGitUp説明とてもシンプルなGUIのGitクライアント特にいいと思うところツリーが見やすい基本的なgitの操作はショートカットキーで素早くできる（あまり複雑な機能はない代わりに）見た目がシンプルいかがでしょうか。気になるものがあれば、ぜひリンクをチェックしてみてください🤲実際聞いてみたところ、「これといったデスクトップアプリはあまり使っていない」「VSCodeでたいていのことができてしまう」といった感想が多く、思ったほど集まりませんでした🤔コマンドラインツールやWebアプリ・Webサービスのほうがいろいろあるという声があったので、気を取り直して次回はそのあたりを集めてみようと思います！</div><div class="ui-feed-item__date" title="2021-04-23 08:35:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://tech-blog.sitateru.com/2021/02/introduce-volta.html"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2021/02/introduce-volta.html">Node.jsのバージョン管理をVoltaに統一したわけ</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
Node.jsを使っていれば永遠のテーマである(?)バージョン管理ですが、皆さんはどのようにしているでしょうか。今更ながら、ローカル環境で使用するバージョン管理を原則としてVoltaに統一する運びになったので、その背景などを書いてみたいと思います。今までは特にバージョン管理ツールを標準で決めておらず、個人やチームでそれぞれ好きなものを使っているような状態でした。それぞれのリポジトリで使っているNodeのバージョンをどこからか見つけてきて切り替えする作業を1日に何度もやるのはやはり効率が悪いしストレスですね。ということで何のツールをツールを使うか検討を始めました。設定しておけばカレントディレクトリに応じて自動でNodeのバージョンが切り替わる設定したバージョンをVCSに記録できるnpmのバージョンも記録して自動切換えできるちなみに最後の条件はnpmのバージョン7がもう一般リリースされているので出てきたものです。npm 7 is now generally available! - The GitHub Blogさて結論ですが、Voltaを使うことにしました。Volta - The Hassle-Free JavaScript Tool Manager使うのも簡単でいい感じですね。$ volta install node@14 npm@6$ volta pin node@14 npm@6とすると package.json にバージョンが書き込まれます。{ ... &quot;volta&quot;: { &quot;node&quot;: &quot;14.15.5&quot;, &quot;npm&quot;: &quot;6.14.11&quot; }}これをgitにコミットしておけば、自動でこのバージョンのnodeとnpmが実行されるようになります。Nodeはもちろん、npmやその他nodeツール類のバージョン管理をしっかりやりたいという方はVoltaを一度試してみてはいかがでしょうか💁‍♂️</div><div class="ui-feed-item__date" title="2021-02-26 04:35:00">3年前</div></div></div><div class="ui-feed-item"><a 
class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2021/01/dependabot-docker-tag.html"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2021/01/dependabot-docker-tag.html">GitHub dependabot でDockerタグをバージョン指定する</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
寒い日が続きますね。ところで皆さんはGitHubのdependabotは使っていますでしょうか？依存関係を自動的に更新する - GitHub Docsそのdependabotでちょっとした問題を調べて解決したので記録しておこうと思います。dependabotはDockerタグにも対応していて、脆弱性対応された新しいバージョンタグがある場合はそれを出すようになっています。docker/Dockerfile をスキャン対象にする場合、コミットしておく設定ファイル .github/dependabot.yml はこのようになります。version: 2updates: - package-ecosystem: &quot;docker&quot; directory: &quot;/docker&quot;さて、基本的にはdependabotはメジャーバージョンアップも含めて最新バージョンにアップデートさせるように動作するようです。node:14.x.x イメージを使っている場合このように node:15 系にアップデートしなよ！というPRが作成されるのです。でもNode.jsはバージョン14はLTSで15はLTSじゃない・・・更新するなら14系の最新にしてほしい！依存関係の更新の設定オプション - GitHub Docsこちらのドキュメントによると、あるバージョンへの更新を無視するためにはdependabot.ymlにそのバージョンを明記すればいいのですが、範囲を定義する場合は、パッケージマネージャーの標準パターンを使用しますDockerタグの標準パターンって何だ・・・？🤔結局わからなかったのでソースを見てみたところ、判定しているのはおそらくこのあたり。dependabot-core/update_checker.rb at main · dependabot/dependabot-core · GitHubバージョンの取り扱いに使っているのは Gem::Versionクラス のようです。class Gem::Version (Ruby 3.0.0 リファレンスマニュアル)ということはGemfileでバージョンを指定するのと同じ記法で良さそうですね。version: 2updates: - package-ecosystem: &quot;docker&quot; directory: &quot;/docker&quot; ignore: - ...
</div><div class="ui-feed-item__date" title="2021-01-15 08:07:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2020/11/aws-ecr-lifecycle-policy.html"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2020/11/aws-ecr-lifecycle-policy.html">AWS ECRのライフサイクルポリシーを設定して自動クリーンアップ</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
今回は軽く、AWS ECR (Elastic Container Registry) の小ネタです。AWSでコンテナを使って何かする場合ECRにコンテナイメージを保存しておくことが多いと思いますが、日ごろからイメージをよくビルド＆プッシュしているとどんどんイメージが増えていきますね。イメージサイズがものすごく大きいとかでなければそれほど料金を食うわけでもないのですが、まず使わない古いイメージをずっと保存しておくこともないよなーと思ったのでそのあたりを設定してみました。ECRではライフサイクルポリシーという機能があり、いろいろな条件を定めてイメージを自動クリーンアップすることができるんですね。Amazon ECRのライフサイクルポリシーでコンテナイメージのクリーンアップ | Amazon Web Services ブログ設定できる条件はタグイメージ数プッシュされてからの経過日数を組み合わせることができます。今回は、「タグが latest ではない」かつ「プッシュされて90日以上」の条件に合うイメージを削除するポリシーを設定してみました。AWSコンソールで設定する場合は、ECRのコンソールでリポジトリを選択して左のメニューの Lifecycle Policy をクリックすると設定画面があります。「テストルールの編集」ボタンを押すとポリシーを適用した結果が確認できる（実際に保存されているイメージには何もしない）テスト用ページに移動するので、まずはそこで試してみるのがいいですね。さて、ライフサイクルポリシーは「ルール」を優先順位つきで好きな数設定することで構成します。ルール作成画面はこうなっていて、一致条件は「イメージをプッシュしてから」「次の数値を超えるイメージ数」が選べます。今回作りたい条件は「タグが latest ではない」かつ「プッシュされて90日以上」ということで、タグ付け済(&quot;latest&quot;)、次の数値を超えるイメージ数(1)すべて、イメージをプッシュしてから(90日)という2つのルールを作ってこのようになります。ルールを作ればあとは自動でそれに従ってイメージが毎日掃除されるので、とても楽ですね😊ここまではコンソールで操作してきましたが、リポジトリが多い場合やコンソール面倒だと言う場合はもちろんCLIが使えます。put-lifecycle-policy — A...
</div><div class="ui-feed-item__date" title="2020-11-12 09:15:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2020/09/gcp-billing-alert-to-slack.html"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2020/09/gcp-billing-alert-to-slack.html">GCPの料金アラートをSlackに出してみる</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
AWSやGCPの料金、たまに気になりますよね。そういえば今月どれくらい料金食ってるんだ？と思ったとき、もちろん各サービスのコンソールで課金管理のページを開けば確認できますね。が、日常的にはお知らせが届くほうが簡単ですむよね、ということでslackに通知をさせてみました。AWSは簡単だったのですがGCPはちょっと手間だったのでまとめておきたいと思います。まあエンジニアとしては課金の具合を気にせず開発に集中できれば一番いいのですが、現実には会社の予算とかいろいろありますし私は課金周りの把握をする役回りもあるので、これはやっておきたいところです。1. Pub/Subトピック作成まずは適当なプロジェクトを用意し、Pub/Sub でトピックを作成します。2.GCPで予算の作成次は予算の作成です。GCPのメニューから「お支払い」→「予算とアラート」と進み、予算の作成をクリック。予算と予算アラートの設定 | Cloud Billing | Google Cloudまずは料金を集計する対象を選択します。プロジェクトやサービスを絞り込んだり、特定のラベルを付けたリソースだけを対象にすることもできます。予算は設定された額に対して実際の課金額が達したら通知されるようになっています。設定額は、「自由に設定」と「先月の額」から選べるんですね。ちなみに5000兆円は設定できませんでした🥺最後に設定額の何％になった時点でアラート出すかのしきい値を設定します。実値or予測値で、パーセンテージは自由に設定できます。あと、先ほど作成したPub/Subトピックを忘れずに接続しておきましょう。3. Slack App作成Slackに通知するために、Appを作成してトークンを発行します。コスト管理の自動レスポンスの例 | Cloud Billing | Google Cloudhttps://api.slack.com/apps で Create New App をクリックし、適当なAPP名と導入したいワークスペース名を入力してアプリを作成します。メニューの OAuth &amp; Permissions を開き、 Bot Token Scopes に chat:write スコープを追加します。ページ上部の Install App to Workspace をクリックし、ワークスペースにAppをインストールしま...
</div><div class="ui-feed-item__date" title="2020-09-04 06:49:00">3年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2020/07/github-actions-self-hosted.html"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2020/07/github-actions-self-hosted.html">GCPでGitHub Actionsのセルフホストランナーを作った</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
朝野です。少し前の話ですが、GitHubの料金が全体的に値下げされましたね。https://github.co.jp/pricing.htmlGitHub ActionsとCypressでサイト監視してみる|sitateru tech blog)で紹介したようなCypressを使った監視をActionsで動かしていたので、月3000分は少ないなーと思って料金を見てみたところ・・・https://github.co.jp/features/actions#pricingセルフホストランナーについて - GitHub DocsGoogle Cloud の無料枠 | Google Cloud Platform の無料枠f1-micro では処理能力的に無理でした。もっと軽い処理なら足りるのかもしれませんが・・・e2-micro ならなんとか動いたのでこれで良しとしましょう。セルフホストランナーの追加 - GitHub Docshttps://github.com/organizations/{organization名}/settings/actions で Add Runner をクリック。するとインストールするコマンドが出てくるので、それを実行すればOKです。簡単ですね。run.sh を実行するだけ。svc.sh でサービスを実行するactions-runner/bin/actions.runner.service.template ファイルを編集して /etc/systemd/system/ あたりにうまいこと設置して systemctl でコントロールする/etc/systemd/system/actions.service を設置しました。[Unit]Description=GitHub Actions RunnerAfter=network.target[Service]ExecStart=/usr/local/actions-runner/runsvc.shUser=devWorkingDirectory=/usr/local/actions-runnerKillMode=processKillSignal=SIGTERMTimeoutStopSec=5min[Install]WantedBy=multi-user.targetセルフホストランナーアプリケー
</div><div class="ui-feed-item__date" title="2020-07-10 08:52:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2020/04/flood-element-load-testing.html"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2020/04/flood-element-load-testing.html">Flood Element でブラウザベースの負荷テスト</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
どうも朝野です。Flood Elementというものを使ってみたので、紹介しようと思います。$ npm install -g @flood/element-cli$ brew install flood-io/taps/element$ element init$ element generate some-test.tspuppeteerを利用しているので、書き方はかなりpuppeteerに近いですね。import { step, TestSettings, By, Until } from &#39;@flood/element&#39;export const settings: TestSettings = { // userAgent: &#39;flood-chrome-test&#39;, loopCount: 10, screenshotOnFailure: true, clearCache: true, clearCookies: true, actionDelay: 1, stepDelay: 1, waitTimeout: 180}export default () =&gt; { step(&#39;Sample&#39;, async browser =&gt; { await browser.visit(&#39;https://google.com&#39;) await browser.click(By.css(&#39;form input[type=&quot;text&quot;]&#39;)) await browser.sendKeys(&#39;flood element&#39;, Key.ENTER) await browser.wait(Until.elementIsVisible(By.css(&#39;div#search&#39;))) await browser.takeScreenshot() })}$ element run some-test.tstmp/element-results/&lt;テストファイル名&gt;/&lt;実行タイムスタンプ&gt; 以下に記録されます。公式ドキュメントを参照してください。Scalable software starts here - FloodちなみにFloodの料金ですが、VUHという単位の使用量によって決まります。Flood Load Testing PricingVUH = Virtual User Hourであり、 (実
</div><div class="ui-feed-item__date" title="2020-04-30 08:38:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2020/03/tech-for-cypress-on-github-actions.html"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2020/03/tech-for-cypress-on-github-actions.html">Cypress on GitHub Actions のいろいろなテクニック</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
朝野です。CypressとGitHubを使う記事を書いたのですが、今回はもう少し突っ込んだ話として、ActionsでCypressを使う上で引っかかったところなどをまとめてみたいと思います。Cypressのテストが止まったままになる？？module.exports = (on, config) =&gt; { on(&#39;before:browser:launch&#39;, (browser, launchOptions) =&gt; { if (browser.name === &#39;chrome&#39;) { launchOptions.args.push(&#39;--disable-dev-shm-usage&#39;) } return launchOptions })}--disable-dev-shm-usage オプションをつけているのですが、これによって共有メモリファイルを /tmp 以下に配置するので充分な容量が確保できるということだそうです。:hoverhover | Cypress Documentationcy.get(&#39;.hidden&#39;).invoke(&#39;show&#39;).click()cy.get(&#39;.hidden&#39;).click({ force: true })invoke(&#39;show&#39;) はうまくいかなかったのですが click({ force: true }) はできたので、これでいいかなということにしました。XPathcypress-xpath を追加し、cypress/support/index.js にrequire(&#39;cypress-xpath&#39;)cy.xpath(&#39;//div[contains(text(), &quot;ここをクリック&quot;)]&#39;) のように要素を取得できます。ESLinteslint-plugin-cypress を追加し、cypress/.eslintrc.jsonを作成します。{ &quot;plugins&quot;: [ &quot;cypress&quot; ], &quot;env&quot;: { &quot;cypress/globals&quot;: true }, &quot;extends&quot;: [ &quot;plugin:cypress/recommended&quot; ]}Cypressだけインストールする$ npm install cypress@4.1.0 --no-save --no-package-locknpm-install | np
</div><div class="ui-feed-item__date" title="2020-03-19 03:46:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2020/02/github-actions-cicdcircleciactions-e2e.html"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2020/02/github-actions-cicdcircleciactions-e2e.html">GitHub ActionsとCypressでサイト監視してみる</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
こんにちは、朝野です。Github Actions使ってますか？Cypressです。テストコードを書いて cypress/integration/ ディレクトリに入れておくnpmでcypressをインストール$ npx cypress run で実行https://sitateru.com/ のページが表示されることをチェックするコードをCypressで書くとこのようになります。describe(&#39;Check page&#39;, function() { it(&#39;top&#39;, function() { // URLを開く cy.visit(&#39;https://sitateru.com/&#39;) // ページタイトルをチェック cy.title().should(&#39;eq&#39;, &#39;sitateru - シタテル - | その服は、つくれる。&#39;) // ページ内に特定の文字列があることを確認する cy.contains(&#39;かんたん無料登録&#39;) // CSSセレクタを使って、要素が存在することを確認する cy.get(&#39;.top-main-visual&#39;).should(&#39;exist&#39;) })})describe(&#39;Login&#39;, function() { it(&#39;login&#39;, function() { cy.visit(&#39;https://atelier.sitateru.com/login&#39;) // フォームに入力 cy.get(&#39;#email&#39;).type(Cypress.env(&#39;LOGIN_EMAIL&#39;)) cy.get(&#39;#password&#39;).type(Cypress.env(&#39;LOGIN_PASSWORD&#39;)) // ログインボタンをクリック cy.get(&#39;input[type=&quot;submit&quot;]&#39;).click() // 遷移先のURLパスをチェック cy.location(&#39;pathname&#39;).should(&#39;eq&#39;, &#39;/topics&#39;) })})CYPRESS_SOMEENV のように CYPRESS_ プレフィックスをつけた環境変数を定義しておくと、コード内で Cypress.env(&#39;SOMEENV&#39;) と書いて呼び出すことができます。.github/workflows/ にやりたいことを書いたyamlファイルを置けば実行されるので簡単ですね。name: e
</div><div class="ui-feed-item__date" title="2020-02-05 09:18:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2019/12/advent-calendar-kubernetesnamespace.html"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2019/12/advent-calendar-kubernetesnamespace.html">安全にkubectl applyするコマンドを作った</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
どうも朝野です。本番環境でやらかしちゃった人 Advent Calendar が話題ですね。私も楽しく読ませてもらっています。新しく作るnamespace以下にkubectl applyでアプリケーションをデプロイしようとした対象のyamlファイルは別プロジェクトのソースファイルをコピーして作ったものだったyaml内に書かれているapply先namespaceが別プロジェクトのnamespaceのままだった環境の切り替え管理にkustomizeを使っている各環境のyamlは k8s/overlays/{環境名} ディレクトリに置いて、kubectl apply -k k8s/overlays/{環境名}でデプロイデプロイ先namespaceは {リポジトリ名}-{環境名} に統一する#!/bin/sh# check whether namespace is {repository}-{env} correctly or notkubectl kustomize $1 &gt; /dev/null 2&gt; /dev/nullif [ $? != 0 ]; then /bin/echo &#39;usage: kubeapply [kustomize_dir]&#39; exit 1fiPROCEED=0REPOSITORY_NAME=$(git rev-parse --show-toplevel | rev | cut -f1 -d&#39;/&#39; | rev)NAMESPACES=$(kubectl kustomize $1 | grep namespace | sed -E &#39;s/namespace:(.*)/&#92;1/&#39; | tr -d &#39; &#39; | sort | uniq)OVERLAY_DIR=$(echo $1/ | tr -s &#39;/&#39; | rev | cut -f2 -d&#39;/&#39; | rev)FOUND=()for NAMESPACE in $NAMESPACESdo if [ ${NAMESPACE} != ${REPOSITORY_NAME}-${OVERLAY_DIR} ]; then FOUND+=(&quot;${NAMESPACE}&quot;) PROCEED=0 else PROCEED=1 fidoneif [ ${PROCEED} = 0 ]; then /bin/echo &quot;expected
</div><div class="ui-feed-item__date" title="2019-12-19 07:38:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2019/10/gasg-suite.html"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2019/10/gasg-suite.html">GASでG Suiteグループ追加をやってみた</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
どうも朝野です。それからオプション設定の「メールアドレスを収集する」をチェック。var privilegedRespondent = [&#39;taro@sitateru.sample&#39;, &#39;jiro@sitateru.sample&#39;];// グループ追加,フォーム送信時に実行function addUserToGroup(event) { console.log(&#39;addUserToGroup()&#39;); var message = &quot;グループ追加フォームからの通知です&#92;n&#92;n&quot;; const respondent = event.response.getRespondentEmail(); if(privilegedRespondent.indexOf(respondent) === -1) { console.log(&#39;Respondent &#39; + respondent + &#39; not allowed&#39;); message += &#39;あなた( &#39; + respondent + &quot; )にはアカウントを作成する権限がありません&#92;n&quot;; sendResult(respondent, message); return; } const response = parseResponse(event.response.getItemResponses()); const userName = response[&#39;追加するユーザー&#39;]; const groups = response[&#39;追加先グループ&#39;].split(&#39;,&#39;); for (var i = 0; i &lt; groups.length; i++) { var groupName = groups[i].trim(); try { var member = addGroupMember(userName, groupName); console.log(&#39; added member&#39;, member); if(member == undefined) { message += &quot;ユーザーをグループに追加できませんでした。入力内容を確認してください&#92;n&quot;; message += &#39; ユーザー: &#39; + userName + &quot;@sitateru.com&#92;n&quot;; message += &#39; グループ: &#39; + groupName
</div><div class="ui-feed-item__date" title="2019-10-11 08:50:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2019/09/sqljson.html"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2019/09/sqljson.html">SQLをつかってJSONで格納されたデータを検索してみた</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
こんにちは！シタテルでエンジニアをしている建山です。今回は、データベース（MySQL）にJSON形式で格納されているデータをSQLで検索する方法を紹介します。シタテルでは、AWS上のデータベースに蓄積されたデータをredashというツールを使い、SQLでデータ抽出したあと、データ分析できるようになっています。やりかた今回はMySQLのたとえば、格納データが以下の2レコードあったとします。{&quot;maxCount&quot;:1000,&quot;targets&quot;:{&quot;ladies&quot;:false,&quot;mens&quot;:true,&quot;kids&quot;:false,&quot;baby&quot;:false}}{&quot;maxCount&quot;:50,&quot;targets&quot;:{&quot;ladies&quot;:true,&quot;mens&quot;:false,&quot;kids&quot;:false,&quot;baby&quot;:false}}ここで、maxCountが50のデータを検索したいときは、JSON_EXTRACTを使用し、以下のように抽出できます。（テーブル名：table_a、JSON格納カラム名：detail）select * from table_a where JSON_EXTRACT(detail, &#39;$.maxCount&#39;) = 50targetsのladiesがtrueの検索をしたいときは、以下のようになります。select * from tablename where JSON_EXTRACT(detail, &#39;$.targets.ladies&#39;) = true# 感想このように、```$.のあとに、キーの名前を指定してあげれば、かんたんに、jsonが格納してあるカラムの中身を検索することができます。（表示の記述方法も同じ）公式のドキュメントはこの辺あたりのようです。https://dev.mysql.com/doc/refman/5.7/en/json.html他にもいくつか関数があるようなので、いろいろ試してみたら、いいSQL+JSONライフが送れるかも知れません！簡単ではありましたが、ご紹介でした！
</div><div class="ui-feed-item__date" title="2019-09-09 03:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2019/09/rpa.html"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2019/09/rpa.html">RPA触ってみた</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
どうもお久しぶりです。シタテルの朝野です。突然ですがRPAってご存知でしょうか？私は数週間前にまともに知りました🙄&quot;Robotic Process Automation&quot; の略で、PC上での作業をソフトウェアロボットが行うよう自動化することです。現在私のいるDevOpsチームでは単純な作業を自動化して時間と手間を節約できないかという取り組みを少しずつ進めています。そんな中でRPAというものの存在を知り、簡単に無償で導入できるものを試してみたので、サンプルと共に紹介します。今回やってみたサンプルは、シタテルの「マイアトリエ」をブラウザで開いてログインするというものです。（※サンプル内のメールアドレスとパスワードはダミーの値です）Javascript for AutomationMacOS Yosemite以降で使用可能なスクリプト言語です。サンプルコードはこのようになります。const DELAY = 3;const Chrome = Application(&quot;Google Chrome&quot;);const window = Chrome.windows[0];const tab = Chrome.Tab({ url: &#39;https://atelier.sitateru.com/login&#39;});window.tabs.push(tab);delay(DELAY);inputText(tab, &#39;email&#39;, &#39;sample@sitateru.sample&#39;);inputText(tab, &#39;password&#39;, &#39;sample_password&#39;);submit(tab);function inputText(tab, elementId, value) { tab.execute({ javascript: &quot;document.getElementById(&#39;&quot; + elementId + &quot;&#39;).value =`&quot; + value + &quot;`;&quot; });}function submit(tab) { tab.execute({ javascript: &quot;document.forms[0].submit();&quot; });}ブラウザ上での入力やクリックはjavascriptをブラウザ内で走らせることで行っています。実行はコマンドで $ osascript -l Java...
</div><div class="ui-feed-item__date" title="2019-09-09 03:00:00">4年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2019/06/blog-post.html"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2019/06/blog-post.html">書評『進化的アーキテクチャ ―絶え間ない変化を支える』</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
『進化的アーキテクチャ ―絶え間ない変化を支える』を読みました。モノリス（3層レイヤ化モノリス等を含む）イベント駆動アーキテクチャSOAマイクロサービスサーバレスまた逆に、モノリスアーキテクチャであっても、ビジネスドメインに基づいてしっかりとモノリス内でモジュール化（疎結合化）が成されていれば、マイクロサービスに近いメリットが得られるということでもあります。ビジネス機能グループ既存のビジネスコミュニケーション階層を反映する。コンウェイの法則に従う。トランザクション境界トランザクションは最も分離しにくい要素である。デプロイメント目標デプロイ頻度が異なる箇所を境界とする。一般的に、結合よりも重複の方が望ましい。たやすく結合できてしまう環境の中で適切な結合を行うことに悪戦苦闘している。あえて重複させるという選択肢を忘れないようにしたいですね。「継続的デプロイは開発側の都合であって、ユーザは頻繁な小規模改修を望んでいない」 という観点はもっともだと思いました。</div><div class="ui-feed-item__date" title="2019-06-03 03:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2019/05/blog-post.html"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2019/05/blog-post.html">プログラミング・ゲーム</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
こんにちは。自分はまだ少ししか触れていませんが、初級からだんだん難しくなっていくレッスン形式になっていて、プログラミングに慣れていない人でも入りやすいのではないかと思います。公式のレッスンの他にもサードパーティのレッスンもあり、センサーやロボット、ドローンを扱うようなものもあるようです。普段のプログラミングや設計からの気分転換にもなって、良いと思います。もう1〜2個紹介しようと思いましたが、長くなりそうなので、続きは次回にしたいと思います。</div><div class="ui-feed-item__date" title="2019-05-08 03:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2019/04/with-tmux.html"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2019/04/with-tmux.html">同時に複数のマシーンで同じ操作をする with Tmux</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
sitateruのエンジニア北爪です。ログを一箇所に集めてないけど、アプリケーションサーバーが複数台ある複数台同時にtopコマンドで負荷をまたはtailコマンドでログを調査したい一つのpaneに行うキーボード操作をそのpaneが存在しているWindow内すべてのpaneキーボード操作を同期することができます。synchronize-panes 機能です。tmuxを使ってない人には導入する大きなメリットの一つになるのではないかとお思います。デフォルトです。http://man.openbsd.org/OpenBSD-current/man1/tmux.1#synchronize-panes# act like GNU screen unbind C-b set -g prefix C-t set synchronize-panes onを入力します。set synchronize-panes off にて解除することが可能です。以上です。</div><div class="ui-feed-item__date" title="2019-04-23 03:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2019/04/vuejsscoped-cssz-index.html"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2019/04/vuejsscoped-cssz-index.html">Vue.jsとScoped CSSとz-indexの話</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div 
class="ui-feed-item__summary">*1」という、シンプルで管理しやすい設計指針を打ち立てることができ、実に理にかなった手法ですね。*2。例えば、コンテキストメニューのコンポーネントはz-index1000番台、モーダルダイアログのコンポーネントはz-index500番台といった管理です。（モーダル上でコンテキストメニューを開くかもしれない。その場合はコンテキストメニューがモーダルの下に回り込んでほしくない、なんてことを考えているわけですね）</div><div class="ui-feed-item__date" title="2019-04-16 03:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2019/04/blog-post.html"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2019/04/blog-post.html">地方活性化のイベントに参加してきました</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
こんにちは、シタテルの藤本です。イベントの参加のために久しぶりに東京に行きましたが、渋谷駅から出られなくなりそうになりました。先日「スマホで見つける地方のしごと」というシンポジウムにパネラーとして求人サイト運営企業地方自治体商工会議所地方への移住者（Uターン）厚生労働省からの本取組みにおける施策のついての説明求人サイト運営企業からのプレゼン地方自治体、商工会議所、移住者からのプレゼンパネルディスカッション転職は孤独であり寄り添うことに注力したい転職は一般的になっている「不安」と戦うことになると思いますが共有・共感者が少ないといった問題があり、そこに「賛成」と後押しすることで生き方を一緒に考えていこうといったものでした。「よりそう」と言葉が定義されており、大きく以下の3つで構成されています。リスペクトする声を聴く感動を与えるシタテルの目指す未来｜シタテル株式会社ポジティブ、ネガティブというより転職は一般化してきている」といわれていることがとても印象的でした。人材育成・確保に向けた種々の取り組みをされているコメリは新潟の上場企業だった地域資源を生かしたビジネスを展開ロケットの打ち上げを成功されている地方がありました。技術者の連携や情報交換、人脈の育成などを推進されているとのことで地方を活性化していくために技術を磨いていくことは大切だなと感じました。東京、大阪についで3位とのことです。地元の金属加工目メーカーが生み出しものということでした。新たなビジネスを生み出すということは素晴らしいなと思い印象的でした。経営者との距離が近くなった「自分がいなくても回る」から「自分がいるから回る」自分を必要とされる、頼られることが強く感じられるようになったということでした。エンジニア│熊本or東京勤務 - シタテル株式会社のWeb エンジニア中途・契約・委託の求人 - Wantedly</div><div class="ui-feed-item__date" title="2019-04-08 07:17:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" 
href="https://tech-blog.sitateru.com/2019/03/javascript-4.html"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2019/03/javascript-4.html">初めて見るとぎょっとするかもしれない JavaScript の構文 4 選</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
こんにちは！ エンジニアの諏訪です。シタテルでは主にフロントエンドを担当しています。ドット３つ ...let array = [ 1, 2, 3 ]let result = [ 0, ...array ]・・・あれ〜？」と脳が一瞬フリーズしてしまうこと必至です。ちなみにだじゃれです。スプレッド構文 (spread syntax) と呼ばれるもので、 ES2015 で導入された新しい記法です。Array や Object の外側の括弧を取り払って丸裸にします。let array = [ 1, 2, 3 ]let result = [ 0, ...array ]console.log(result)// =&gt; [0, 1, 2, 3]let obj1 = { potato: 2, carrot: 3, onion: 5, niku: 8 }let obj2 = { water: 65535, spice: Infinity }let result = { ...obj1, ...obj2 }console.log(result)// =&gt; { &quot;potato&quot;: 2, &quot;carrot&quot;: 3, &quot;onion&quot;: 5, &quot;niku&quot;: 8, &quot;water&quot;: 65535, &quot;spice&quot;: Infinity }function createUser(firstName, lastName, bornYear, bornMonth, bornDay) { // doSomeProcess}let name = [&#39;Colonel&#39;, &#39;Sanders&#39;]let birthday = [1890, 9, 9]let user = createUser(...name, ...birthday) // =&gt; createUser(&#39;Colonel&#39;, &#39;Sanders&#39;, 1890, 9, 9) を実行するのと同じビックリマーク２つ !!びっくりびっくりしたことがあります。Boolean (真偽値) 以外の値を Boolean にキャストしたいときに使うと便利です。function hasName (user) { return ( user.name !== undefined &amp;&amp; user.name !== null &amp;&amp; user.name !== &#39;&#39; )}funct
</div><div class="ui-feed-item__date" title="2019-03-12 03:00:00">5年前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://tech-blog.sitateru.com/2019/03/good-project-award-2019.html"><img src="../../images/alternate-feed-image.png" loading="lazy" alt="記事のアイキャッチ画像" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://tech-blog.sitateru.com/2019/03/good-project-award-2019.html">Good Project Award 2019で最優秀賞をいただきました！</a><div class="ui-feed-item__blog-title">sitateru tech blog</div><div class="ui-feed-item__summary">
こんにちは！シタテル株式会社UI/UXデザイナーの田仲です。私が担当しているマイオペレーター（以下、マイオペ）という縫製工場の生産管理者向けのシステムが、「JBUG(ジェイバグ：Japan Backlog User Group)」が開催する『Backlog World 2019』内の『Good Project Award 2019』にて最優秀賞を獲得いたしました。『Backlog World 2019』とは株式会社ヌーラボの日本最大級のプロジェクト管理ツール”Backlog(バックログ)”のユーザーコミュニティである”JBUG(ジェイバグ)”が主催した、プロジェクト管理に関わる全ての方のための祭典です。Backlog Worldとして2回目の今年は、「プロジェクトマネジメント×働き方改革」というテーマで、 数々のセッションやワークショップ、情報共有の場、Good Project Award(表彰イベント)などでプロジェクト管理に関する知見を相互に高め合うことを目的としています。2019年1月26日(土)、秋葉原UDXにて開催されました。https://backlogworld2019.jbug.info/『Good Project Award 2019』とは2018年〜2019年に活動したプロジェクトの課題やそれに対するアクション、その結果得られたことのストーリーを通し、プロジェクトマネジメントのヒントが共有されることを目指したアワードです。Backlog Worldイベント内コンテンツとして「Good Project Award 2019」というピッチコンテストが開催され、来場者投票と審査員の審査により、最も素晴らしいものを表彰します。『Good Project Award 2019』への応募経緯アワードの存在を知ったCTOの和泉さんから「だしてみたら？」ともちかけてもらったのがきっかけです。マイオペは2018年の頭から立ち上げ開始し、7月ごろにリリースをしました。Backlogは使用していなかったのですが、応募条件に利用有無は問われていなかった、応募することにしました。『Good Project Award 2019』に登壇するまでエントリーフォームより応募2018年末頃に、プロジェクトの目的や結果、熱い想いを書きました。エントリーについての情報https://
</div><div class="ui-feed-item__date" title="2019-03-04 03:00:00">5年前</div></div></div></div></div></section></main><footer role="contentinfo" class="ui-section-footer"><div class="ui-layout-container"><div class="ui-layout-column-6 ui-layout-column-center"><div class="ui-component-cta ui-layout-flex ui-section-footer__site-info"><p class="ui-text-note">このサイトは<br>記事を読んでその企業の技術・カルチャーを知れることや<br>質の高い技術情報を得られることを目的としています。</p><p class="ui-text-note">追加したいブログがある場合は<br><a href="https://github.com/yamadashy/tech-blog-rss-feed#%E3%82%B5%E3%82%A4%E3%83%88%E3%81%AE%E8%BF%BD%E5%8A%A0%E6%96%B9%E6%B3%95">サイトの追加方法</a> をご参照ください。</p></div></div></div><div class="ui-layout-container"><div class="ui-section-footer__layout ui-layout-flex"><p class="ui-section-footer--copyright ui-text-note"><a class="ui-text-note" href="https://github.com/yamadashy/"><small>@yamadashy</small></a></p><a href="https://github.com/yamadashy/tech-blog-rss-feed/" role="link" aria-label="#" class="ui-text-note"><small>GitHub
</small></a></div></div></footer></body></html>